# 03-事务隔离

MySQL 实战 45 讲03 | 事务隔离：为什么你改了我还看不见？

内容包括：

- MySQL 的事务
  - 原子性 Atomicity
  - 一致性 Consistency
  - 隔离性 Isolation
  - 持久性 Durability
- 隔离级别
  - 读未提交 read uncommitted
  - 读提交 read committed
  - 可重复读 repeatable read
  - 串行化 serializable

## ACID 特性

事务 (Transaction)，可看作是对数据库操作的基本执行单元，可能包含一个或者多个 SQL 语句。事务就是要保证一组数据库操作，要么全部成功，要么全部失败。

MyISAM 引擎不支持事务，InnoDB 引擎支持事务。

事务的执行主要包括两个操作，提交和回滚：

- 提交：commit，将事务执行结果写入数据库
- 回滚：rollback，回滚所有已经执行的语句，返回修改之前的数据

事务的 ACID 特性：

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；主要基于 undo log 日志实现；
2. **一致性**（`Consistency`）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏，保证事务提交后不会因为宕机等原因导致数据丢失；是事务追求的最终目标，通过原子性、隔离性、持久性来保证一致性；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；InnoDB 引擎通过锁机制、MVCC  等手段来保证事务的隔离性；
4. **持久性**（`Durability`）： 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响；基于 redo log 日志实现

## 并发事务带来的问题

- 脏读（dirty read）：当前事务中读到其他事务未提交的数据，也就是脏数据；
- 不可重复读（non-repeatable read）：A 事务多次读取同一个数据，而 B 事务中修改该数据导致 A 事务两次读取的数据可能不太一样；脏读与不可重复读的区别在于：**前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。**
- 幻读（phantom read）： 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。不可重复读与幻读的区别为：**前者是数据变了，后者是数据的行数变了。**

## 事务的隔离级别

隔离得越严实，效率就会越低。因此很多时候，都要在二者之间寻找一个平衡点。

SQL 标准的事务隔离级别包括：

- **READ-UNCOMMITTED (读未提交)：** 最低的隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED (读取已提交)：** 一个事务提交之后，它做的变更才会被其他事务看到。可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ (可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 隔离级别         | 脏读       | 不可重复读 | 幻读       |
| ---------------- | ---------- | ---------- | ---------- |
| READ-UNCOMMITTED | 可能发生   | 可能发生   | 可能发生   |
| READ-COMMITTED   | 不可能发生 | 可能发生   | 可能发生   |
| REPEATABLE-READ  | 不可能发生 | 不可能发生 | 可能发生   |
| SERIALIZABLE     | 不可能发生 | 不可能发生 | 不可能发生 |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读），同时使用到了MVCC 和 Next-Key Locks 机制解决了幻读，详见 [06-MVCC](06-MVCC.md)

## 事务隔离的实现

## 事务的启动方式