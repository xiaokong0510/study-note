# 06-进一步理解MVCC

课程链接：
- [MySQL 实战 45 讲 08 | 事务到底是隔离的还是不隔离的？](https://time.geekbang.org/column/article/70562)

内容包括：

- 一致性视图、当前读、快照读
- MVCC 里的快照
- ReadView 读视图

## 一致性读视图

可重复读隔离级别下，视图在事务启动时就创建好，整个事务期间都看到的是**事务刚刚启动时候的视图**。

因为行锁，事务在执行过程中可能需要等待别的事务更新同一行，那这时候如果该事务也要更新，看到的还是事务刚刚创建时事务的状态吗？ 显然不是，这里的关键就是**对于更新操作来说，需要当前读。**

在 MySQL 里，有两个“视图”的概念：

1. **view** ：一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。

   创建视图的语法是 `create view … `，查询方法与表一样。

2. **一致性视图**：InnoDB 在实现 MVCC 时用到，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

   consistent read view 没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。通过高低水位，数据版本号，undo log来进行判断数据可见性，达到 MVCC 目的。

## MVCC 里的快照

在可重复读隔离级别下，事务在启动的时候就拍了个快照，这个快照是基于整库的。但是并不需要拷贝出全库的数据，通过 undo log 版本链实现的。

**InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**

### 事务 ID

InnoDB 里面每个事务有一个唯一的事务 ID： **transaction id**，在事务开始时向 InnoDB 的事务系统申请，按申请顺序严格递增。

在 MySQL 的数据表中，每条记录有 2 个隐藏字段：

- **row_trx_id** ：创建或者最后一次修改该记录的 transaction id
- **roll_pointer**：回滚指针，指向该行数据上一个版本的 undo log

### undo log 版本链

每次修改某行记录时，会把 undo 日志地址赋值给 roll_pointer 隐藏列，将一行数据连接成一个版本链，然后各个事务通过当前的事务 ID 和数据行的版本链进行对比，拿到它该读的版本数据。

一个记录被多个事务连续更新后的状态如下图所示。

![image-20221116231659110](http://image.kongxiao.top/20221116231700.png)

- 虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25
- 三个虚线箭头就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。

按照可重复读的定义，一个事务在启动时：

- 以其启动的时刻为准，**能够看到所有已经提交的事务结果**；如果是其启动以后才生成的，就不认，必须要找到它的上一个版本，如果上一个版本也不可见，那就继续往前找；
- 这个事务执行期间，其他事务的更新对它不可见；
- 如果是这个事务自己更新的数据，它自己还是要认。

参考文档：[一文搞懂Undo Log版本链与ReadView机制如何让事务读取到该读的数据](https://www.51cto.com/article/641019.html)

### ReadView 读视图

InnoDB 为每个事务构造了一个数组，**用来保存这个事务启动瞬间，当前正在活跃的所有事务 ID**，活跃指的就是，启动了但还没提交。

- **低水位**：数组里面事务 ID 的最小值
- 高水位：当前系统里面已经创建过的事务 ID 的最大值加 1 

这个视图数组和高水位，就组成了当前事务的**一致性视图（read-view）**。

### 可见性判断

数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。

![image-20221116232554202](http://image.kongxiao.top/20221116232555.png)

对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

- 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
- 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
- 如果落在黄色部分，那就包括两种情况：
  - 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
  - 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。


### 完整案例分析

事务启动时机：

- 使用 `begin/start transaction` ，**在执行到它之后的第一个操作 InnoDB 表的语句，事务才真正启动**；一致性视图是在执行第一个快照读语句时创建的；
- 使用 `start transaction with consistent snapshot` 可以马上启动一个事务，一致性视图是在执行改语句时创建的。

案例：

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![image-20221117233130908](http://image.kongxiao.top/20221117233131.png)

假设：

- 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
- 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
- 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。

![image-20221117233303581](http://image.kongxiao.top/20221117233304.png)

操作过程分析：

1. 事务 C 把数据从 (1,1) 改成了 (1,2)，此时数据的最新版本（即 row trx_id）是 102，90 成为历史版本；
2. 事务 B 把数据从 (1,2) 改成了 (1,3)，此时数据的 row trx_id 是 101，而 102 又成为了历史版本；
3. 在事务 A 查询的时候，事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。这个版本对事务 A 必须是不可见的，否则就变成脏读了。

读数据都是从当前版本读起的，事务 A 查询语句的读数据流程：

   - 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；
   - 找到上一个历史版本，row trx_id=102，比高水位大，处于红色区域，不可见；
   - 再往前找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见

虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，称之为**一致性读**。

> 总结：
>
> 一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：
>
> - 版本未提交，不可见；
> - 版本已提交，但是是在视图创建后提交的，不可见；
> - 版本已提交，而且是在视图创建前提交的，可见。

## 更新逻辑

更新数据都是先读后写的，而这个读，只能读当前的值，即**“当前读”（current read）**。

### 当前读

- 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录；
- 触发方式：
  - `select...lock in share mode`（读锁）
  - `select...for update`（写锁）
  - `update` , `delete` , `insert`
- 通过 next-key 锁 (行记录锁+Gap 间隙锁) 实现

### 快照读

- 读取的是历史版本的记录；
- RC 隔离级别，每次 select 都生成一个快照读；
- RR 隔离级别，开启事务后第一个 select 语句才是快照读的地方；
- 通过 undolog 实现

### 事务的可重复读

1. 可重复读的核心就是一致性读（consistent read），而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占着的话，就需要进入锁等待；
2. 读已提交和可重复的逻辑类似，主要区别为：
   - RR 级别下，只需要事务开始的时候创建一致性视图，之后事务里的其他查询都是用这个一致性视图
   - RC 级别下，每个语句执行前都会重新算出一个新的视图。

## 总结
InnoDB 的行数据有多个版本，每个数据版本都有自己的 row trx_id，这个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性：

1. 可重复读：查询只承认在事务启动前的就已经提交完成的数据。
2. 读已提交：查询只承认在语句启动前就已经提交完成的数据。
3. 当前读，总是读取当前已经提交完成的最新版本。

