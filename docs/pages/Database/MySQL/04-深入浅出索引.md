# 04-深入浅出索引
>数据库底层存储的核心就是基于数据模型。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。

课程链接：
- [MySQL 实战 45 讲 04 | 深入浅出索引（上）](https://time.geekbang.org/column/article/69236)
- [MySQL 实战 45 讲 05 | 深入浅出索引（下）](https://time.geekbang.org/column/article/69636)

内容包括：
- 索引的常见模型
  - Hash 表
  - 有序数组
  - 搜索树
- InnoDB 的索引模型
- 覆盖索引
- 最左前缀原则
- 索引下推

## 索引的常见模式
索引的出现是为了提高查询效率，实现索引的方式有很多种。
### Hash 表

定义：
- `hash` 是一种函数，**把任意长度的输入转换为固定长度的输出**，输出的结果称为 hash 值；
- 哈希表是一种以键 - 值（key-value）存储数据的结构，只要输入待查找的键即 key，就可以找到其对应的值即 Value。

特性：
- 多个 key 值经过哈希函数的换算，会出现同一个值的情况（**hash 碰撞**）；拉链法解决；
- **适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎；不适用于范围查询。

例子：维护一个身份证信息和姓名的表，根据身份证号查找对应的名字，对应的哈希索引如下所示：

  ![image-20221017232259767](http://image.kongxiao.top/20221017232308.png)

User2 和 User4 根据身份证号算出来的值都是 N，拉出一个链表。

要查 ID_card_n2 对应的名字，首先将 ID_card_n2 通过哈希函数算出 N，然后按顺序遍历找到 User2。

### 有序数组

适用于等值查询和范围查询场景。

例子：假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的，如下图所示：

![image-20221017232457985](http://image.kongxiao.top/20221017232459.png)

特性：

- 要查 ID_card_n2 对应的名字，使用**二分法**，时间复杂度 O(log(N))；
- **支持范围查询**。要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环；
- 更新数据时间复杂度为 O(n)，往中间插入一个记录必须挪动后面所有的记录，成本太高，因此**只适用于静态存储引擎**。比如要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

### 搜索树

用二叉搜索树来实现：

![image-20221017233018787](http://image.kongxiao.top/20221017233019.png)

二叉搜索树：
- **父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值；**
- 查找时间复杂度近似等于二分法，但前提是二叉搜索树近似平衡；
- 二叉搜索树有可能出现极坏的情况，变成链表；

平衡二叉树：
- 为了维持 O(log(N)) 的查询复杂度，需要保持这棵树是平衡二叉树，更新的时间复杂度也是 O(log(N))

N 叉树：
- 索引不止存在内存中，还要写到磁盘上。如果二叉树树高过高，每次查询都需要访问过多节点；
- 为了让一个查询尽量少地读磁盘，要使用“N 叉”树，“N”取决于数据块的大小。

MySQL 默认一个节点的长度为 16K，一个整数（bigint）字段索引的长度为 8B，另外每个索引还跟着 6B 的指向其子树的指针，所以16K/14B ≈ 1170。这棵树高是 4 的时候，就可以存 1170 的 3 次方个值，这已经 16 亿了。

参考：https://blog.csdn.net/weixin_35871519/article/details/113303881

## InnoDB 的索引模型

在 MySQL 中，索引是在存储引擎层实现的。

InnoDB 使用了 **B+ 树索引模型**，数据都是存储在 B+ 树中的。**每一个索引在 InnoDB 里面对应一棵 B+ 树。**

案例：有一个主键列为 ID 的表 T，表中有字段 k，并且在 k 上有索引。

```sql
create table T (
   id int primary key,
   k int not null, 
   name varchar(16),
   index (k)
) engine=InnoDB;
```

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵索引树的示意图如下：

![image-20221024233004949](http://image.kongxiao.top/20221024233013.png)



### B+ 树和 B 树的区别

- B 树的所有节点既存放 key 也存放 data；B+树只有叶子节点存放 key 和 data，其他内节点只存放 key；
-  B+ 树的叶子节点有一条双向链表串连与它相邻的叶子节点，区间查询效率更高；
-  B+树查询效率更高，因为B+树矮更胖，高度小，减少单次查询的磁盘访问次数。

### 索引的分类

- 从数据结构角度
  - 树索引 (O(log(n)))
  - Hash 索引

- 从功能角度
  - 普通索引
  - 唯一性索引
  - 主键索引
  - 全文索引

- 从物理实现
  - 聚簇索引：叶子节点存的是整行数据；InnoDB 的主键索引是聚集索引；
  - 非聚簇索引：叶子节点内容是主键的值，也称为二级索引或者辅助索引；

### 回表

定义：InnoDB 普通索引的叶子节点存储主键值，查询时需要先定位主键值，再通过主键索引定位行记录

基于主键索引和普通索引的查询的区别：

- `select * from T where ID=500`，即主键查询方式，只需要搜索 ID 这棵 B+ 树；
-  `select * from T where k=5`，即普通索引查询方式，需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。

基于非主键索引的查询需要多扫描一棵索引树，在应用中应该尽量使用主键查询。

### 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护：

- 新插入中间值，需要逻辑上挪动后面的数据，空出位置；
- **页分裂**：如果数据页已经满了，需要申请一个新的数据页，然后挪动部分数据过去。会影响性能和数据页的使用率；
- **页合并**：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。

建议使用自增长主键作为索引的原因（性能和存储空间）：

- B+树存储数据的特点是从左到右是有序的，在插入数据时，如果不是有序插入，会导致B+树的叶子节点分裂，存在移动数据的情况，影响插入数据性能；
- 自增长主键在插入过程中能尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；减少数据的移动，每次插入都是插入到最后；
- 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 覆盖索引

定义：查询的数据列从索引中就能够取得，不必读取数据行，即**查询列被所建的索引覆盖**。

作用：覆盖索引可以减少树的搜索次数，显著提升查询性能，使用覆盖索引是一个常用的性能优化手段。

举例：

- 执行 `select * from T where k between 3 and 5`：
  1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
  2. 再到 ID 索引树查到 ID=300 对应的 R3；
  3. 在 k 索引树取下一个值 k=5，取得 ID=500；
  4. 再回到 ID 索引树查到 ID=500 对应的 R4；
  5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。

查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。

- 执行 `select ID from T where k between 3 and 5`：
  1. 只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表

## 最左前缀原则

**联合索引**：表上多个列加起来组成一个索引；与在写 where 条件后的顺序无关，MySQL 会查询分析会进行优化而使用索引；联合索引也拥有单列索引的作用。

举例：市民信息表如下

```sql
CREATE TABLE `tuser` (
    `id` int(11) NOT NULL,
    `id_card` varchar(32) DEFAULT NULL,
    `name` varchar(32) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    `ismale` tinyint(1) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB
```

- `id_card`是市民的唯一标识。根据`id_card`查询市民信息，则建立索引 (`id_card`)；
- 如果要根据`id_card`查询`id_card`，再建立一个（`id_card`,`name`）的联合索引，可以用到覆盖索引，不再需要回表查整行记录；

索引字段的维护总是有代价的，在建立冗余索引来支持覆盖索引时就需要权衡考虑。

**最左前缀原则**：组合索引中，最左优先，以最左边的为起点任何连续的索引都能匹配上。比如说联合索引里有字段 a,b,c 那么 a, ab, abc 都是可以走这个索引。遇到范围查询 (>、<、between、like) 就会停止匹配。

举例：（name，age）联合索引

![image-20221026232550280](http://image.kongxiao.top/20221026232551.png)

- 查到所有 `name`是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果；
- 查的`name`第一个字是“张”的人：`where name like '张%'`，也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止；

最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

在建立联合索引的时候，安排索引内的字段顺序需要考虑的因素：

- **索引的复用能力**。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
- **空间**。如果既有联合查询，又有基于 a、b 各自的查询。(a,b)、(b) 还是 (b,a)、(a)？考虑空间，字段长的只建立一次，短的建立两次。

## 索引下推

定义：**在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**MySQL 5.6 引入的索引下推优化。

满足最左前缀原则，可以用于在索引中定位记录，而那些不符合最左前缀的部分，如何处理？

举例：

建立了联合索引（`name`, `age`），执行以下 SQL 

```sql
select * from tuser where name like '张%' and age = 10 and ismale = 1;
```

根据前缀索引规则，“张”可以用到联合索引中的 `name`，找到第一个满足条件的记录 ID3，然后判断其他条件是否满足。

在 MySQL 5.6 之前，不会去看 `age` 的值，只能从 ID3 开始一个个回表，到主键索引上找出数据行，再对比字段值，需要回表 4 次。

![image-20221026234022823](http://image.kongxiao.top/20221026234024.png)

MySQL 5.6 引入索引下推优化。InnoDB 在（`name`, `age`） 索引内部就判断了 `age` 是否等于 10，对于不等于 10 的记录，直接判断并跳过。只需要对 ID4、ID5 这两条记录回表取数据判断，回表 2 次。

![image-20221026234035391](http://image.kongxiao.top/20221026234040.png)

----

思考题 1：针对上表 T，如果要重建普通索引 k 或者主键索引，如何理解下面两个 SQL 语句：

```sql
# 重建索引
alter table T drop index k;
alter table T add index(k);

# 重建主键索引
alter table T drop primary key;
alter table T add primary key(id);
```

>为什么要重建索引？
>
>因为当对InnoDB进行修改操作时，例如删除一些行，这些行只是被标记为“已删除”，而不是真的从索引中物理删除了，因而空间也没有真的被释放回收。重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

答案：重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。**不论是删除主键还是创建主键，都会将整个表重建**。所以连着执行这两个语句的话，第一个语句就白做了。

这两个语句，可以用这个语句代替 ：`alter table T engine=InnoDB`，这个语句在 InnobDB 里会触发 MySQL 重建该表，并进行碎片处理.

----

思考题 2：有一个表结构定义如下：

```sql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

为了以下两个查询模式，“ca”“cb”这两个索引是否都是必须的？

```sql
select * from geek where c = N order by a limit 1;
select * from geek where c = N order by b limit 1;
```

答案：ca 可以去掉，cb 需要保留。

**二级索引索引扩展**： InnoDB 的二级索引会自动补齐主键，将主键列追加到二级索引列后面，同时也会去重，若主键的部分列已经包含在二级索引中，则不会再重复记录该列。参考：https://dev.mysql.com/doc/refman/5.7/en/index-extensions.html

1. c 字段上创建了索引，所以最终的叶子节点值为(c,a,b)，即索引节点+主键； 
2. ca 上创建索引，由于a是主键的一部分，所以叶子节点不会再重复添加 a （c,a,a,b），而是（c,a,b）；那么这颗索引树和 1 中的重复了，所以可以去掉； 
3. cb 上创建索引，叶子节点为（c,b,a）

