(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{274:function(v,_,t){"use strict";t.r(_);var o=t(13),r=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"mysql-的事务与日志系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的事务与日志系统"}},[v._v("#")]),v._v(" MySQL 的事务与日志系统")]),v._v(" "),_("p",[v._v("简单总结 MySQL 的日志系统，包含以下内容：")]),v._v(" "),_("ul",[_("li",[v._v("MySQL 的事务\n"),_("ul",[_("li",[v._v("原子性 Atomicity")]),v._v(" "),_("li",[v._v("一致性 Consistency")]),v._v(" "),_("li",[v._v("隔离性 Isolation")]),v._v(" "),_("li",[v._v("持久性 Durability")])])]),v._v(" "),_("li",[v._v("MySQL 的日志系统\n"),_("ul",[_("li",[v._v("redo log（重做日志）")]),v._v(" "),_("li",[v._v("undo log（回滚日志）")]),v._v(" "),_("li",[v._v("bin log（归档日志）")])])])]),v._v(" "),_("h2",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),_("p",[v._v("事务 (Transaction)，可看作是对数据库操作的基本执行单元，可能包含一个或者多个SQL语句")]),v._v(" "),_("p",[v._v("事务就是要保证一组数据库操作，要么全部成功，要么全部失败")]),v._v(" "),_("p",[v._v("MyISAM 引擎不支持事务，InnoDB 引擎支持事务")]),v._v(" "),_("h2",{attrs:{id:"事务的acid-特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的acid-特性"}},[v._v("#")]),v._v(" 事务的ACID 特性")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("原子性")]),v._v("（"),_("code",[v._v("Atomicity")]),v._v("） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；实现主要基于 undo log 日志实现；")]),v._v(" "),_("li",[_("strong",[v._v("一致性")]),v._v("（"),_("code",[v._v("Consistency")]),v._v("）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏，保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于 redo log 日志；")]),v._v(" "),_("li",[_("strong",[v._v("隔离性")]),v._v("（"),_("code",[v._v("Isolation")]),v._v("）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；InnoDB 引擎通过锁机制、MVCC  等手段来保证事务的隔离性；")]),v._v(" "),_("li",[_("strong",[v._v("持久性")]),v._v("（"),_("code",[v._v("Durability")]),v._v("）： 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。")])]),v._v(" "),_("h2",{attrs:{id:"并发事务带来的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来的问题"}},[v._v("#")]),v._v(" 并发事务带来的问题")]),v._v(" "),_("ul",[_("li",[v._v("脏读（dirty read）：当前事务中读到其他事务未提交的数据，也就是脏数据；")]),v._v(" "),_("li",[v._v("不可重复读（non-repeatable read）：A 事务多次读取同一个数据，而 B 事务中修改该数据导致 A 事务两次读取的数据可能不太一样；脏读与不可重复读的区别在于："),_("strong",[v._v("前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。")])]),v._v(" "),_("li",[v._v("幻读（phantom read）： 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。不可重复读与幻读的区别为："),_("strong",[v._v("前者是数据变了，后者是数据的行数变了。")])])]),v._v(" "),_("h2",{attrs:{id:"事务的隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离级别"}},[v._v("#")]),v._v(" 事务的隔离级别")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("READ-UNCOMMITTED (读取未提交)：")]),v._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),_("strong",[v._v("可能会导致脏读、幻读或不可重复读")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("READ-COMMITTED (读取已提交)：")]),v._v(" 允许读取并发事务已经提交的数据，"),_("strong",[v._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("REPEATABLE-READ (可重复读)：")]),v._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),_("strong",[v._v("可以阻止脏读和不可重复读，但幻读仍有可能发生")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("SERIALIZABLE(可串行化)：")]),v._v(" 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),_("strong",[v._v("该级别可以防止脏读、不可重复读以及幻读")]),v._v("。")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("隔离级别")]),v._v(" "),_("th",[v._v("脏读")]),v._v(" "),_("th",[v._v("不可重复读")]),v._v(" "),_("th",[v._v("幻读")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("READ-UNCOMMITTED")]),v._v(" "),_("td",[v._v("可能发生")]),v._v(" "),_("td",[v._v("可能发生")]),v._v(" "),_("td",[v._v("可能发生")])]),v._v(" "),_("tr",[_("td",[v._v("READ-COMMITTED")]),v._v(" "),_("td",[v._v("不可能发生")]),v._v(" "),_("td",[v._v("可能发生")]),v._v(" "),_("td",[v._v("可能发生")])]),v._v(" "),_("tr",[_("td",[v._v("REPEATABLE-READ")]),v._v(" "),_("td",[v._v("不可能发生")]),v._v(" "),_("td",[v._v("不可能发生")]),v._v(" "),_("td",[v._v("可能发生")])]),v._v(" "),_("tr",[_("td",[v._v("SERIALIZABLE")]),v._v(" "),_("td",[v._v("不可能发生")]),v._v(" "),_("td",[v._v("不可能发生")]),v._v(" "),_("td",[v._v("不可能发生")])])])]),v._v(" "),_("p",[v._v("MySQL InnoDB 存储引擎的默认支持的隔离级别是 "),_("strong",[v._v("REPEATABLE-READ（可重读）")])]),v._v(" "),_("p",[_("strong",[v._v("使用到 Next-Key Locks 机制解决了幻读。")])]),v._v(" "),_("h2",{attrs:{id:"redo-log"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[v._v("#")]),v._v(" redo log")]),v._v(" "),_("p",[v._v("redo log 是 InnoDB 引擎层的日志，用来记录事务操作引起数据的变化，记录的是数据页的物理修改。")]),v._v(" "),_("p",[v._v("redo log 分为 redo log buffer 和 redo log file，buffer 到 file 是通过 os buffer 写入，写入机制分别为【延迟写】: 每秒从 redo log buffer 写入到 os buffer 和 redo log file， 【实时写，实时刷】: 即无延时实时写入，【实时写，延迟刷】: 每次写入到 os buffer 后每秒刷到 redo log file")]),v._v(" "),_("p",[v._v("真正的“两阶段提交” 是指对 redo log 进行“两阶段提交”：先 prepare，再commit。 数据库 crash-重启后，会对记录对redo log 进行check： 1、如果 redo log 已经commit，则视为有效。 2、如果 redo log prepare 但未commit，则check对应的bin log记录是否记录成功。 2.1、bin log记录成功则将该prepare状态的redo log视为有效 2.2、bin log记录不成功则将该prepare状态的redo log视为无效")]),v._v(" "),_("p",[v._v("参考文档：https://www.cxyxiaowu.com/10740.html")])])}),[],!1,null,null,null);_.default=r.exports}}]);