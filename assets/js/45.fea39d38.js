(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{322:function(v,_,e){"use strict";e.r(_);var t=e(10),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"api接口签名验证与参数加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#api接口签名验证与参数加密"}},[v._v("#")]),v._v(" API接口签名验证与参数加密")]),v._v(" "),_("p",[v._v("刚开始写代码时，接口都是裸奔的，客户端抓个包，就能知道所有的请求参数和返回参数，对于一些重要的接口，这样是不安全的。")]),v._v(" "),_("p",[v._v("后来公司开始对所有业务接口进行参数加密处理，就学习了接口的签名和加密的相关规则，做个记录。")]),v._v(" "),_("h2",{attrs:{id:"_1-问题引出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-问题引出"}},[v._v("#")]),v._v(" 1 问题引出")]),v._v(" "),_("p",[v._v("调用API接口时，请求方和接口提供方之间的通信过程，需要考虑几个问题：")]),v._v(" "),_("ul",[_("li",[v._v("请求参数是否被篡改；")]),v._v(" "),_("li",[v._v("请求来源是否合法；")]),v._v(" "),_("li",[v._v("请求是否具有唯一性；")])]),v._v(" "),_("p",[_("strong",[v._v("举个例子：")])]),v._v(" "),_("p",[v._v("客户端 app 调用产品信息查询 api 进行产品查询：")]),v._v(" "),_("blockquote",[_("p",[v._v("请求: http://api.test.com/getproducts?key1=value1&key2=value2")])]),v._v(" "),_("p",[v._v("没有进行任何的验证，接口处于裸奔状态，所有人都可以通过这个接口获取到产品列表，导致产品信息泄露。")]),v._v(" "),_("h2",{attrs:{id:"_2-参数签名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-参数签名"}},[v._v("#")]),v._v(" 2 参数签名")]),v._v(" "),_("p",[v._v("首先进行一个小优化："),_("strong",[v._v("调用API 时需对请求参数进行签名验证")]),v._v(" ，规则如下：")]),v._v(" "),_("ul",[_("li",[v._v('将所有入参（sign 除外）按照 "key=value" 的格式拼接起来，并且将拼接以后的字符串以 "&" 字符连接。顺序按首字母升序排列，值为空的不参与签名。将拼接好的字符串做 MD5 签名。')])]),v._v(" "),_("blockquote",[_("p",[v._v("即：MD5(key1=value1&key2=value2)")])]),v._v(" "),_("ul",[_("li",[v._v("将生成的签名 sign 添加在请求参数中")])]),v._v(" "),_("blockquote",[_("p",[v._v("新的接口：http://api.test.com/getproducts?key1=value1&key2=value2&sign=...")])]),v._v(" "),_("ul",[_("li",[v._v("后端对请求的 sign 进行校验，需要携带正确的sign才能获取产品数据。")])]),v._v(" "),_("p",[v._v("但是，只对请求参数进行做 MD5 签名得到的 sign 还是不安全的，别人同样可以做相同的加密操作进行请求 。")]),v._v(" "),_("h2",{attrs:{id:"_3-accesskey-secretkey"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-accesskey-secretkey"}},[v._v("#")]),v._v(" 3 AccessKey & SecretKey")]),v._v(" "),_("p",[v._v("进一步优化方法：")]),v._v(" "),_("p",[v._v("为开发者分配 "),_("strong",[v._v("AccessKey")]),v._v("（开发者标识，确保唯一）和 "),_("strong",[v._v("SecretKey")]),v._v("（用于接口加密)")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("请求参数中也携带 AccessKey；")])]),v._v(" "),_("li",[_("p",[v._v("app 和后端约定一个 SecretKey，用于生成签名；")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("在上述请求参数字符串中尾部加上 SecretKey 组成一个新字符串，再进行 MD5 加密得到签名 sign")]),v._v("。")]),v._v(" "),_("p",[v._v("当然也可以使用其他的加密算法")])])]),v._v(" "),_("blockquote",[_("p",[v._v("即：MD5(key1=value1&key2=value2secret)")])]),v._v(" "),_("p",[v._v("请求携带参数"),_("strong",[v._v("AccessKey")]),v._v("和"),_("strong",[v._v("Sign")]),v._v("，只有拥有合法的身份 AccessKey 和正确的签名 sign 才能放行。这样就解决了身份验证和参数篡改问题。")]),v._v(" "),_("p",[v._v("如果参数被篡改，没事，因为别人无法知道 SecretKey，也就无法重新生成新的 sign。")]),v._v(" "),_("p",[v._v("注：SecretKey 仅作加密使用, 不参与网络传输，为了保证数据安全请不要在请求参数中使用。")]),v._v(" "),_("h2",{attrs:{id:"_4-请求唯一性保证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-请求唯一性保证"}},[v._v("#")]),v._v(" 4 请求唯一性保证")]),v._v(" "),_("p",[v._v("但是...这样就够了吗？")]),v._v(" "),_("p",[v._v("MD5 签名方法可以保证来源及请求参数的合法性，但是请求链接可能会被抓包而造成泄露，人家拿着这个请求链接反复请求，就可以正常获取数据了，即 "),_("strong",[v._v("重放攻击")]),v._v("，因此仅仅是如上的优化是不够的！")]),v._v(" "),_("p",[v._v("再次优化：")]),v._v(" "),_("ul",[_("li",[v._v("在如上的请求参数中带上 "),_("strong",[v._v("时间戳")]),v._v(" ，并且把时间戳也作为签名的一部分。在接口提供方对时间戳进行验证，只允许一定时间范围内的请求，假设为 5 分钟。后端先校验时间戳，相差超过 5 分钟的请求直接拒绝。")])]),v._v(" "),_("blockquote",[_("p",[v._v("新的接口：http://api.test.com/getproducts?key1=value1&key2=value2&timestamp=...&sign=...")])]),v._v(" "),_("p",[v._v("以上可以使用自定义注解 + 拦截器进行实现。")]),v._v(" "),_("h2",{attrs:{id:"_5-参数加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-参数加密"}},[v._v("#")]),v._v(" 5 参数加密")]),v._v(" "),_("h3",{attrs:{id:"对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[v._v("#")]),v._v(" 对称加密")]),v._v(" "),_("p",[_("code",[v._v("Symmetric Cryptography")]),v._v("，是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）使用同样的密钥（secret key）。")]),v._v(" "),_("p",[v._v("常见的对称加密算法如 AES，Advanced Encryption Standard。")]),v._v(" "),_("p",[v._v("对称加密的缺点是密钥的管理与分配，即如何发送秘钥。因为在发送密钥的过程中，密钥有很大的风险被拦截。"),_("strong",[v._v("通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的一方。")])]),v._v(" "),_("h3",{attrs:{id:"非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[v._v("#")]),v._v(" 非对称加密")]),v._v(" "),_("p",[_("code",[v._v("Asymmetric Cryptography")]),v._v("，使用了一对密钥，**公钥（public key） ** 和 "),_("strong",[v._v("私钥（private key）")]),v._v("。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。私钥是不会通过网络发送出去，因此安全性大大提高。")]),v._v(" "),_("p",[v._v("目前最常用的非对称加密算法是 RSA 算法")]),v._v(" "),_("h3",{attrs:{id:"加密方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加密方案"}},[v._v("#")]),v._v(" 加密方案")]),v._v(" "),_("p",[v._v("目前采用的加密流程为：")]),v._v(" "),_("ol",[_("li",[v._v("为不同的客户端 app 分配了不同的 RSA 加密的公钥，私钥保存在服务器中；")]),v._v(" "),_("li",[v._v("客户端 app 随机生成 AES 密钥并通过 RSA 加密放在请求 header 中；")]),v._v(" "),_("li",[v._v("服务端使用 RSA  的私钥，解密出 AES 密钥原文，从而解密出请求参数；进行业务处理；")]),v._v(" "),_("li",[v._v("使用客户端发过来的 AES 密钥将返回数据加密返回")])]),v._v(" "),_("p",[v._v("以上流程可以在过滤器中实现。")]),v._v(" "),_("h2",{attrs:{id:"_6-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-总结"}},[v._v("#")]),v._v(" 6 总结")]),v._v(" "),_("p",[v._v("接口签名校验和参数加密是非常常见的接口保护手段。")]),v._v(" "),_("ol",[_("li",[v._v("签名校验使用了 AccessKey & SecretKey + timestamp 的方式，对请求参数进行 MD5 加密得到签名 sign；")]),v._v(" "),_("li",[v._v("参数加密同时使用了 AES 和 RSA 两种加密算法，对称加密的密钥进行非对称加密后传输。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);