(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{300:function(t,a,s){"use strict";s.r(a);var _=s(3),n=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_06-进一步理解mvcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_06-进一步理解mvcc"}},[t._v("#")]),t._v(" 06-进一步理解MVCC")]),t._v(" "),a("p",[t._v("课程链接：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://time.geekbang.org/column/article/70562",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 实战 45 讲 08 | 事务到底是隔离的还是不隔离的？"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("内容包括：")]),t._v(" "),a("ul",[a("li",[t._v("一致性视图、当前读、快照读")]),t._v(" "),a("li",[t._v("MVCC 里的快照")]),t._v(" "),a("li",[t._v("ReadView 读视图")])]),t._v(" "),a("h2",{attrs:{id:"一致性读视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一致性读视图"}},[t._v("#")]),t._v(" 一致性读视图")]),t._v(" "),a("p",[t._v("可重复读隔离级别下，视图在事务启动时就创建好，整个事务期间都看到的是"),a("strong",[t._v("事务刚刚启动时候的视图")]),t._v("。")]),t._v(" "),a("p",[t._v("因为行锁，事务在执行过程中可能需要等待别的事务更新同一行，那这时候如果该事务也要更新，看到的还是事务刚刚创建时事务的状态吗？ 显然不是，这里的关键就是"),a("strong",[t._v("对于更新操作来说，需要当前读。")])]),t._v(" "),a("p",[t._v("在 MySQL 里，有两个“视图”的概念：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("view")]),t._v(" ：一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。")]),t._v(" "),a("p",[t._v("创建视图的语法是 "),a("code",[t._v("create view …")]),t._v("，查询方法与表一样。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("一致性视图")]),t._v("：InnoDB 在实现 MVCC 时用到，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。")]),t._v(" "),a("p",[t._v("consistent read view 没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。通过高低水位，数据版本号，undo log来进行判断数据可见性，达到 MVCC 目的。")])])]),t._v(" "),a("h2",{attrs:{id:"mvcc-里的快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvcc-里的快照"}},[t._v("#")]),t._v(" MVCC 里的快照")]),t._v(" "),a("p",[t._v("在可重复读隔离级别下，事务在启动的时候就拍了个快照，这个快照是基于整库的。但是并不需要拷贝出全库的数据，通过 undo log 版本链实现的。")]),t._v(" "),a("p",[a("strong",[t._v("InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。")])]),t._v(" "),a("h3",{attrs:{id:"事务-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务-id"}},[t._v("#")]),t._v(" 事务 ID")]),t._v(" "),a("p",[t._v("InnoDB 里面每个事务有一个唯一的事务 ID： "),a("strong",[t._v("transaction id")]),t._v("，在事务开始时向 InnoDB 的事务系统申请，按申请顺序严格递增。")]),t._v(" "),a("p",[t._v("在 MySQL 的数据表中，每条记录有 2 个隐藏字段：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("row_trx_id")]),t._v(" ：创建或者最后一次修改该记录的 transaction id")]),t._v(" "),a("li",[a("strong",[t._v("roll_pointer")]),t._v("：回滚指针，指向该行数据上一个版本的 undo log")])]),t._v(" "),a("h3",{attrs:{id:"undo-log-版本链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-版本链"}},[t._v("#")]),t._v(" undo log 版本链")]),t._v(" "),a("p",[t._v("每次修改某行记录时，会把 undo 日志地址赋值给 roll_pointer 隐藏列，将一行数据连接成一个版本链，然后各个事务通过当前的事务 ID 和数据行的版本链进行对比，拿到它该读的版本数据。")]),t._v(" "),a("p",[t._v("一个记录被多个事务连续更新后的状态如下图所示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.kongxiao.top/20221116231700.png",alt:"image-20221116231659110"}})]),t._v(" "),a("ul",[a("li",[t._v("虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25")]),t._v(" "),a("li",[t._v("三个虚线箭头就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。")])]),t._v(" "),a("p",[t._v("按照可重复读的定义，一个事务在启动时：")]),t._v(" "),a("ul",[a("li",[t._v("以其启动的时刻为准，"),a("strong",[t._v("能够看到所有已经提交的事务结果")]),t._v("；如果是其启动以后才生成的，就不认，必须要找到它的上一个版本，如果上一个版本也不可见，那就继续往前找；")]),t._v(" "),a("li",[t._v("这个事务执行期间，其他事务的更新对它不可见；")]),t._v(" "),a("li",[t._v("如果是这个事务自己更新的数据，它自己还是要认。")])]),t._v(" "),a("p",[t._v("参考文档："),a("a",{attrs:{href:"https://www.51cto.com/article/641019.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文搞懂Undo Log版本链与ReadView机制如何让事务读取到该读的数据"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"readview-读视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readview-读视图"}},[t._v("#")]),t._v(" ReadView 读视图")]),t._v(" "),a("p",[t._v("InnoDB 为每个事务构造了一个数组，"),a("strong",[t._v("用来保存这个事务启动瞬间，当前正在活跃的所有事务 ID")]),t._v("，活跃指的就是，启动了但还没提交。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("低水位")]),t._v("：数组里面事务 ID 的最小值")]),t._v(" "),a("li",[t._v("高水位：当前系统里面已经创建过的事务 ID 的最大值加 1")])]),t._v(" "),a("p",[t._v("这个视图数组和高水位，就组成了当前事务的"),a("strong",[t._v("一致性视图（read-view）")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"可见性判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可见性判断"}},[t._v("#")]),t._v(" 可见性判断")]),t._v(" "),a("p",[t._v("数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.kongxiao.top/20221116232555.png",alt:"image-20221116232554202"}})]),t._v(" "),a("p",[t._v("对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：")]),t._v(" "),a("ul",[a("li",[t._v("如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；")]),t._v(" "),a("li",[t._v("如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；")]),t._v(" "),a("li",[t._v("如果落在黄色部分，那就包括两种情况：\n"),a("ul",[a("li",[t._v("若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；")]),t._v(" "),a("li",[t._v("若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。")])])])]),t._v(" "),a("h3",{attrs:{id:"完整案例分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完整案例分析"}},[t._v("#")]),t._v(" 完整案例分析")]),t._v(" "),a("p",[t._v("事务启动时机：")]),t._v(" "),a("ul",[a("li",[t._v("使用 "),a("code",[t._v("begin/start transaction")]),t._v(" ，"),a("strong",[t._v("在执行到它之后的第一个操作 InnoDB 表的语句，事务才真正启动")]),t._v("；一致性视图是在执行第一个快照读语句时创建的；")]),t._v(" "),a("li",[t._v("使用 "),a("code",[t._v("start transaction with consistent snapshot")]),t._v(" 可以马上启动一个事务，一致性视图是在执行改语句时创建的。")])]),t._v(" "),a("p",[t._v("案例：")]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[a("img",{attrs:{src:"http://image.kongxiao.top/20221117233131.png",alt:"image-20221117233130908"}})]),t._v(" "),a("p",[t._v("假设：")]),t._v(" "),a("ul",[a("li",[t._v("事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；")]),t._v(" "),a("li",[t._v("事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；")]),t._v(" "),a("li",[t._v("三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://image.kongxiao.top/20221117233304.png",alt:"image-20221117233303581"}})]),t._v(" "),a("p",[t._v("操作过程分析：")]),t._v(" "),a("ol",[a("li",[t._v("事务 C 把数据从 (1,1) 改成了 (1,2)，此时数据的最新版本（即 row trx_id）是 102，90 成为历史版本；")]),t._v(" "),a("li",[t._v("事务 B 把数据从 (1,2) 改成了 (1,3)，此时数据的 row trx_id 是 101，而 102 又成为了历史版本；")]),t._v(" "),a("li",[t._v("在事务 A 查询的时候，事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。这个版本对事务 A 必须是不可见的，否则就变成脏读了。")])]),t._v(" "),a("p",[t._v("读数据都是从当前版本读起的，事务 A 查询语句的读数据流程：")]),t._v(" "),a("ul",[a("li",[t._v("找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；")]),t._v(" "),a("li",[t._v("找到上一个历史版本，row trx_id=102，比高水位大，处于红色区域，不可见；")]),t._v(" "),a("li",[t._v("再往前找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见")])]),t._v(" "),a("p",[t._v("虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，称之为"),a("strong",[t._v("一致性读")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("总结：")]),t._v(" "),a("p",[t._v("一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：")]),t._v(" "),a("ul",[a("li",[t._v("版本未提交，不可见；")]),t._v(" "),a("li",[t._v("版本已提交，但是是在视图创建后提交的，不可见；")]),t._v(" "),a("li",[t._v("版本已提交，而且是在视图创建前提交的，可见。")])])]),t._v(" "),a("h2",{attrs:{id:"更新逻辑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新逻辑"}},[t._v("#")]),t._v(" 更新逻辑")]),t._v(" "),a("p",[t._v("更新数据都是先读后写的，而这个读，只能读当前的值，即**“当前读”（current read）**。")]),t._v(" "),a("h3",{attrs:{id:"当前读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当前读"}},[t._v("#")]),t._v(" 当前读")]),t._v(" "),a("ul",[a("li",[t._v("读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录；")]),t._v(" "),a("li",[t._v("触发方式：\n"),a("ul",[a("li",[a("code",[t._v("select...lock in share mode")]),t._v("（读锁）")]),t._v(" "),a("li",[a("code",[t._v("select...for update")]),t._v("（写锁）")]),t._v(" "),a("li",[a("code",[t._v("update")]),t._v(" , "),a("code",[t._v("delete")]),t._v(" , "),a("code",[t._v("insert")])])])]),t._v(" "),a("li",[t._v("通过 next-key 锁 (行记录锁+Gap 间隙锁) 实现")])]),t._v(" "),a("h3",{attrs:{id:"快照读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照读"}},[t._v("#")]),t._v(" 快照读")]),t._v(" "),a("ul",[a("li",[t._v("读取的是历史版本的记录；")]),t._v(" "),a("li",[t._v("RC 隔离级别，每次 select 都生成一个快照读；")]),t._v(" "),a("li",[t._v("RR 隔离级别，开启事务后第一个 select 语句才是快照读的地方；")]),t._v(" "),a("li",[t._v("通过 undolog 实现")])]),t._v(" "),a("h3",{attrs:{id:"事务的可重复读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务的可重复读"}},[t._v("#")]),t._v(" 事务的可重复读")]),t._v(" "),a("ol",[a("li",[t._v("可重复读的核心就是一致性读（consistent read），而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占着的话，就需要进入锁等待；")]),t._v(" "),a("li",[t._v("读已提交和可重复的逻辑类似，主要区别为：\n"),a("ul",[a("li",[t._v("RR 级别下，只需要事务开始的时候创建一致性视图，之后事务里的其他查询都是用这个一致性视图")]),t._v(" "),a("li",[t._v("RC 级别下，每个语句执行前都会重新算出一个新的视图。")])])])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("InnoDB 的行数据有多个版本，每个数据版本都有自己的 row trx_id，这个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性：")]),t._v(" "),a("ol",[a("li",[t._v("可重复读：查询只承认在事务启动前的就已经提交完成的数据。")]),t._v(" "),a("li",[t._v("读已提交：查询只承认在语句启动前就已经提交完成的数据。")]),t._v(" "),a("li",[t._v("当前读，总是读取当前已经提交完成的最新版本。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);