(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{297:function(e,v,_){"use strict";_.r(v);var t=_(10),o=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"redis-五大数据结构及常用指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-五大数据结构及常用指令"}},[e._v("#")]),e._v(" Redis 五大数据结构及常用指令")]),e._v(" "),v("p",[e._v("官网：https://redis.io/        http://www.redis.cn/")]),e._v(" "),v("p",[e._v("Redis 命令参考：  http://doc.redisfans.com/ ， http://www.redis.cn/commands.html")]),e._v(" "),v("p",[v("em",[e._v("Redis")]),e._v("（Remote Dictionary Server )，即远程字典服务，是一个使用 C 语言开发的数据库。")]),e._v(" "),v("p",[v("strong",[e._v("Redis 的数据是存在内存中的")])]),e._v(" "),v("p",[v("strong",[e._v("Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。")])]),e._v(" "),v("p",[v("strong",[e._v("Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。")])]),e._v(" "),v("h2",{attrs:{id:"常见数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见数据结构"}},[e._v("#")]),e._v(" 常见数据结构")]),e._v(" "),v("ul",[v("li",[e._v("string")]),e._v(" "),v("li",[e._v("list")]),e._v(" "),v("li",[e._v("hash")]),e._v(" "),v("li",[e._v("set")]),e._v(" "),v("li",[e._v("sorted set")])]),e._v(" "),v("h2",{attrs:{id:"redis-命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-命令"}},[e._v("#")]),e._v(" Redis 命令")]),e._v(" "),v("h3",{attrs:{id:"key-键"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#key-键"}},[e._v("#")]),e._v(" Key（键）")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("检查/ 删除 /移动 key：")])])]),e._v(" "),v("p",[v("code",[e._v("EXISTS key")]),e._v("   ：若 key 存在，返回 1 ，否则返回 0 ；\n"),v("code",[e._v("DEL key [key ...]")]),e._v("  ： 删除给定的一个或多个 key，不存在的 key 会被忽略，返回 被删除 key 的数量；\n"),v("code",[e._v("MOVE key db")]),e._v("  ：移动到给定的数据库 db 当中，成功返回 1 ，失败则返回 0 。如果源数据库和目标数据库有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果\n"),v("code",[e._v("TYPE key")]),e._v("  ： 返回 key 所储存的值的类型\n"),v("code",[e._v("RENAME key newkey")]),e._v("  ： 将 key 改名为 newkey；当  key 不存在时，返回一个错误；当 newkey 已经存在时， RENAME 命令将覆盖旧值")]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("strong",[e._v("生存时间：")])])]),e._v(" "),v("p",[v("code",[e._v("TTL key")]),e._v("  ：  TTL, time to live，以秒为单位\n"),v("code",[e._v("PTTL key")]),e._v(" ：以毫秒为单位")]),e._v(" "),v("ul",[v("li",[e._v("当 key 不存在时，返回 -2 ；")]),e._v(" "),v("li",[e._v("当 key 存在但没有设置剩余生存时间时，返回 -1 ；")]),e._v(" "),v("li",[e._v("否则，以秒为单位，返回 key 的剩余生存时间")])]),e._v(" "),v("p",[v("code",[e._v("EXPIRE key seconds")]),e._v("  ： 设置生存时间，单位为 s，设置成功返回 1，\n"),v("code",[e._v("PEXPIRE key milliseconds")]),e._v("  ： 设置生存时间，单位为 ms")]),e._v(" "),v("p",[v("code",[e._v("EXPIREAT key timestamp")]),e._v("  ： 设置生存时间，参数为 UNIX 时间戳\n"),v("code",[e._v("PEXPIREAT key milliseconds-timestamp")]),e._v("  ： 设置生存时间，以毫秒为单位的 UNIX 时间戳")]),e._v(" "),v("p",[v("code",[e._v("PERSIST key timestamp")]),e._v("  ： 移除给定 key 的生存时间，即设置为永久；当生存时间移除成功时，返回 1 ；如果 key 不存在或 key 没有设置生存时间，返回 0")]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("strong",[e._v("查找/扫描：")])])]),e._v(" "),v("p",[v("code",[e._v("KEYS pattern")]),e._v("  ：查找所有符合给定模式 pattern 的 key")]),e._v(" "),v("ul",[v("li",[e._v("KEYS * 匹配数据库中所有 key 。")]),e._v(" "),v("li",[e._v("KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。")]),e._v(" "),v("li",[e._v("KEYS h*llo 匹配 hllo 和 heeeeello 等。")]),e._v(" "),v("li",[e._v("KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo")])]),e._v(" "),v("p",[v("code",[e._v("SCAN cursor [MATCH pattern] [COUNT count]")]),e._v("  ：查找所有符合给定模式 pattern 的 key")]),e._v(" "),v("h3",{attrs:{id:"string-字符串"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#string-字符串"}},[e._v("#")]),e._v(" String（字符串）")]),e._v(" "),v("ol",[v("li",[v("strong",[e._v("基本操作：")])])]),e._v(" "),v("p",[v("code",[e._v("SET key value [EX seconds] [PX milliseconds] [NX|XX]")]),e._v("  ： 设置 key-value 类型的值；key 已经存在则覆写旧值，无视类型，这个键原有的 TTL 也将被清除。支持以下参数")]),e._v(" "),v("ul",[v("li",[e._v("EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value")]),e._v(" "),v("li",[e._v("PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value")]),e._v(" "),v("li",[e._v("NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。")]),e._v(" "),v("li",[e._v("XX ：只在键已经存在时，才对键进行设置操作。")])]),e._v(" "),v("p",[v("code",[e._v("GET key")]),e._v("  ： 根据 key 获得对于的 value，如果 key 不存在那么返回特殊值 nil")]),e._v(" "),v("p",[v("code",[e._v("STRLEN key")]),e._v("  ： 返回 key 所储存的字符串值的长度\n"),v("code",[e._v("SETRANGE key offset value")]),e._v('  ： 从偏移量 offset 开始设置 key 所保存的 value，返回被 SETRANGE 修改之后字符串的长度；不存在的 key 当作空白字符串处理，空白处被"\\x00"填充')]),e._v(" "),v("p",[v("code",[e._v("GETRANGE key start end")]),e._v("  ：返回截取后的字符串， 包括 start 和 end 在内；负数偏移量表示从字符串最后开始计数，-1 表示最后一个字符， -2 表示倒数第二个")]),e._v(" "),v("p",[v("code",[e._v("SETEX key seconds value")]),e._v("  ： 将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)")]),e._v(" "),v("p",[v("code",[e._v("SETNX key value")]),e._v("  ：即 【SET if Not eXists】。 当且仅当 key 不存在时，将 key 的值设为 value ；若给定的 key 已经存在，则不做任何动作。设置成功，返回 1 ；设置失败，返回 0 。")]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("strong",[e._v("批量设置：")])])]),e._v(" "),v("p",[v("code",[e._v("MSET key value [key value ...]")]),e._v("  ： 同时设置一个或多个 key-value 对；是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置\n"),v("code",[e._v("MGET key [key ...]")]),e._v("  ：返回所有(一个或多个)给定 key 的值。")]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("strong",[e._v("计数器：")])])]),e._v(" "),v("p",[v("code",[e._v("DECR key")]),e._v("  ： 将 key 中储存的数字值增一；如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作\n"),v("code",[e._v("INCRBY key")]),e._v("  ： 将 key 所储存的值加上增量 increment 。\n"),v("code",[e._v("INCR key")]),e._v("  ： 将 key 中储存的数字值减一；如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作\n"),v("code",[e._v("INCRBY key")]),e._v("  ： 将 key 所储存的值减去减量 decrement")]),e._v(" "),v("h3",{attrs:{id:"list-列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list-列表"}},[e._v("#")]),e._v(" List（列表）")]),e._v(" "),v("p",[v("code",[e._v("RPUSH key value [value ...]")]),e._v("  ： 右边插入；返回执行 RPUSH 操作后，表的长度\n"),v("code",[e._v("LPOP key")]),e._v("  ： 移除并返回列表 key 最左边的元素\n"),v("code",[e._v("LPUSH key value [value ...]")]),e._v("  ： 左边插入；返回执行 LRPUSH 操作后，表的长度\n"),v("code",[e._v("RPOP key")]),e._v("  ： 移除并返回列表 key 最右边的元素")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://image.kongxiao.top/20210922175322.png",alt:"redis-list"}})]),e._v(" "),v("p",[v("code",[e._v("LLEN key")]),e._v("  ： 返回列表 key 的长度，如果 key 不存在，则 key 被解释为一个空列表，返回 0，\n如果 key 不是列表类型，返回一个错误\n"),v("code",[e._v("LRANGE key start stop")]),e._v("  ： 返回列表 key 中指定区间内的元素，-1表示倒数第一\n"),v("code",[e._v("LINDEX key index")]),e._v("  ： 返回列表 key 中，下标为 index 的元素")]),e._v(" "),v("p",[v("code",[e._v("LINSERT key BEFORE|AFTER pivot value")]),e._v("  ： 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("当 pivot 不存在于列表 key 时，不执行任何操作；")])]),e._v(" "),v("li",[v("p",[e._v("当 key 不存在时， key 被视为空列表，不执行任何操作；")])]),e._v(" "),v("li",[v("p",[e._v("如果 key 不是列表类型，返回一个错误；")])]),e._v(" "),v("li",[v("p",[e._v("如果命令执行成功，返回插入操作完成之后，列表的长度；")])]),e._v(" "),v("li",[v("p",[e._v("如果没有找到 pivot ，返回 -1 ；")])]),e._v(" "),v("li",[v("p",[e._v("如果 key 不存在或为空列表，返回 0")])])]),e._v(" "),v("p",[v("code",[e._v("LREM key count value")]),e._v("：根据参数 count 的值，移除列表中与参数 value 相等的元素。返回被移除元素的数量")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count ；")])]),e._v(" "),v("li",[v("p",[e._v("count < 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值；")])]),e._v(" "),v("li",[v("p",[e._v("count = 0 : 移除表中所有与 value 相等的值")])])]),e._v(" "),v("h3",{attrs:{id:"hash-哈希表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash-哈希表"}},[e._v("#")]),e._v(" Hash（哈希表）")]),e._v(" "),v("p",[v("code",[e._v("HSET key filed value [filed value ...]")]),e._v("：设置 key 中的域 field 的值设为 value\n"),v("code",[e._v("HGET key filed")]),e._v("：返回指定 key 中给定域 field 的值")]),e._v(" "),v("p",[v("code",[e._v("HLEN key")]),e._v("：返回指定 key 中域的数量")]),e._v(" "),v("p",[v("code",[e._v("HGETALL key")]),e._v("：返回指定key 所有的域和值")]),e._v(" "),v("p",[v("code",[e._v("HEXISTS key filed")]),e._v("：查看指定key，指定域 field 是否存在")]),e._v(" "),v("p",[v("code",[e._v("HDEL key filed[field ...]")]),e._v("：删除指定 key 中，一个或多个给定的 field")]),e._v(" "),v("p",[v("code",[e._v("HKEYS key")]),e._v("：返回指定key 中，所有的 field")]),e._v(" "),v("p",[v("code",[e._v("HVALS key")]),e._v("：返回指定key，所有的 field 的 value")]),e._v(" "),v("p",[v("code",[e._v("HSETNX key field value")]),e._v("：当且仅当域 field 不存在，将指定 key 中的域 field 的值设置为 value")]),e._v(" "),v("p",[v("code",[e._v("HINCRBY key field increment")]),e._v("：为指定 key 中的域 field 的值加上增量 increment")]),e._v(" "),v("h3",{attrs:{id:"set-集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[e._v("#")]),e._v(" SET （集合）")]),e._v(" "),v("p",[v("code",[e._v("SADD key member [member ...]")]),e._v(" ：添加元素")]),e._v(" "),v("p",[v("code",[e._v("SMEMBERS key")]),e._v("：查看所有元素\n"),v("code",[e._v("SISMEMBERS key member")]),e._v("：判断 member 元素是否是集合 key 的成员")]),e._v(" "),v("p",[v("code",[e._v("SCARD key")]),e._v("：查看元素个数")]),e._v(" "),v("p",[v("code",[e._v("SREM key member [member ...]")]),e._v("：移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略")]),e._v(" "),v("p",[v("code",[e._v("SPOP key")]),e._v("：移除并返回集合中的一个随机元素")]),e._v(" "),v("p",[v("code",[e._v("SRANDMEMBER key [count]")]),e._v("：返回集合中的一个随机元素")]),e._v(" "),v("ul",[v("li",[e._v("如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素"),v("strong",[e._v("各不相同")]),e._v("。如果 count 大于等于集合基数，那么返回整个集合")]),e._v(" "),v("li",[e._v("如果 count 为负数，那么命令返回一个数组，数组中的元素"),v("strong",[e._v("可能会重复出现多次")]),e._v("，而数组的长度为 count 的绝对值")])]),e._v(" "),v("p",[v("code",[e._v("SMOVE source destination member")]),e._v("：将 member 元素从 source 集合移动到 destination 集合")]),e._v(" "),v("p",[v("strong",[e._v("数学集合类：")])]),e._v(" "),v("p",[v("code",[e._v("SDIFF key [key ...]")]),e._v("：返回所有给定集合之间的差集\n"),v("code",[e._v("SINNER key [key ...]")]),e._v("：返回所有给定集合之间的交集\n"),v("code",[e._v("SUNION key [key ...]")]),e._v("：返回所有给定集合之间的并集")]),e._v(" "),v("p",[v("code",[e._v("SDIFFSTORE destination key [key ...]")]),e._v("：返回所有给定集合之间的差集，将结果保存到 destination 集合\n"),v("code",[e._v("SINNERSTORE destination key [key ...]")]),e._v("：返回所有给定集合之间的交集，将结果保存到 destination 集合\n"),v("code",[e._v("SUNIONSTORE destination key [key ...]")]),e._v("：返回所有给定集合之间的并集，将结果保存到 destination 集合")]),e._v(" "),v("h3",{attrs:{id:"zset-sorted-set有序集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zset-sorted-set有序集合"}},[e._v("#")]),e._v(" ZSET（Sorted Set有序集合）")]),e._v(" "),v("p",[e._v("在 SET 基础上，加上一个 scroe 值")]),e._v(" "),v("p",[v("code",[e._v("ZADD key score member [[score member] [score member] ...]")]),e._v("：将一个或多个 member 元素及其 score 值加入到有序集 key 当中")]),e._v(" "),v("p",[v("code",[e._v("ZRANGE key start stop [WITHSCORES]")]),e._v("：返回有序集 key 中，指定区间内的成员，其中成员的位置按 score 值递增(从小到大)来排序")]),e._v(" "),v("p",[v("code",[e._v("ZREVRANGE key start stop [WITHSCORES]")]),e._v("：同上，逆序")]),e._v(" "),v("p",[v("code",[e._v("ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]")]),e._v("：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列")]),e._v(" "),v("p",[v("code",[e._v("ZREVRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]")]),e._v("：同上，逆序")]),e._v(" "),v("p",[v("code",[e._v("ZSCORE key member")]),e._v("：返回有序集 key 中，成员 member 的 score 值")]),e._v(" "),v("p",[v("code",[e._v("ZRANK key member")]),e._v("：返回有序集 key 中成员 member 的排名")]),e._v(" "),v("p",[v("code",[e._v("ZCARD key")]),e._v("：查看元素个数")]),e._v(" "),v("p",[v("code",[e._v("ZCOUNT key min max")]),e._v("：返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量")]),e._v(" "),v("p",[v("code",[e._v("ZREM key member [member ...]")]),e._v("：移除有序集 key 中的一个或多个成员")])])}),[],!1,null,null,null);v.default=o.exports}}]);