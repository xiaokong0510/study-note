(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{285:function(_,v,t){"use strict";t.r(v);var a=t(10),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_03-事务隔离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_03-事务隔离"}},[_._v("#")]),_._v(" 03-事务隔离")]),_._v(" "),v("p",[_._v("MySQL 实战 45 讲03 | 事务隔离：为什么你改了我还看不见？")]),_._v(" "),v("p",[_._v("内容包括：")]),_._v(" "),v("ul",[v("li",[_._v("MySQL 的事务\n"),v("ul",[v("li",[_._v("原子性 Atomicity")]),_._v(" "),v("li",[_._v("一致性 Consistency")]),_._v(" "),v("li",[_._v("隔离性 Isolation")]),_._v(" "),v("li",[_._v("持久性 Durability")])])]),_._v(" "),v("li",[_._v("隔离级别\n"),v("ul",[v("li",[_._v("读未提交 read uncommitted")]),_._v(" "),v("li",[_._v("读提交 read committed")]),_._v(" "),v("li",[_._v("可重复读 repeatable read")]),_._v(" "),v("li",[_._v("串行化 serializable")])])])]),_._v(" "),v("h2",{attrs:{id:"acid-特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#acid-特性"}},[_._v("#")]),_._v(" ACID 特性")]),_._v(" "),v("p",[_._v("事务 (Transaction)，可看作是对数据库操作的基本执行单元，可能包含一个或者多个 SQL 语句。事务就是要保证一组数据库操作，要么全部成功，要么全部失败。")]),_._v(" "),v("p",[_._v("MyISAM 引擎不支持事务，InnoDB 引擎支持事务。")]),_._v(" "),v("p",[_._v("事务的执行主要包括两个操作，提交和回滚：")]),_._v(" "),v("ul",[v("li",[_._v("提交：commit，将事务执行结果写入数据库")]),_._v(" "),v("li",[_._v("回滚：rollback，回滚所有已经执行的语句，返回修改之前的数据")])]),_._v(" "),v("p",[_._v("事务的 ACID 特性：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("原子性")]),_._v("（"),v("code",[_._v("Atomicity")]),_._v("） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；主要基于 undo log 日志实现；")]),_._v(" "),v("li",[v("strong",[_._v("一致性")]),_._v("（"),v("code",[_._v("Consistency")]),_._v("）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏，保证事务提交后不会因为宕机等原因导致数据丢失；是事务追求的最终目标，通过原子性、隔离性、持久性来保证一致性；")]),_._v(" "),v("li",[v("strong",[_._v("隔离性")]),_._v("（"),v("code",[_._v("Isolation")]),_._v("）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；InnoDB 引擎通过锁机制、MVCC  等手段来保证事务的隔离性；")]),_._v(" "),v("li",[v("strong",[_._v("持久性")]),_._v("（"),v("code",[_._v("Durability")]),_._v("）： 一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响；基于 redo log 日志实现")])]),_._v(" "),v("h2",{attrs:{id:"并发事务带来的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来的问题"}},[_._v("#")]),_._v(" 并发事务带来的问题")]),_._v(" "),v("ul",[v("li",[_._v("脏读（dirty read）：当前事务中读到其他事务未提交的数据，也就是脏数据；")]),_._v(" "),v("li",[_._v("不可重复读（non-repeatable read）：A 事务多次读取同一个数据，而 B 事务中修改该数据导致 A 事务两次读取的数据可能不太一样；脏读与不可重复读的区别在于："),v("strong",[_._v("前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。")])]),_._v(" "),v("li",[_._v("幻读（phantom read）： 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。不可重复读与幻读的区别为："),v("strong",[_._v("前者是数据变了，后者是数据的行数变了。")])])]),_._v(" "),v("h2",{attrs:{id:"事务的隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离级别"}},[_._v("#")]),_._v(" 事务的隔离级别")]),_._v(" "),v("p",[_._v("隔离得越严实，效率就会越低。因此很多时候，都要在二者之间寻找一个平衡点。")]),_._v(" "),v("p",[_._v("SQL 标准的事务隔离级别包括：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("READ-UNCOMMITTED (读未提交)：")]),_._v(" 最低的隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。可能会导致脏读、幻读或不可重复读。")]),_._v(" "),v("li",[v("strong",[_._v("READ-COMMITTED (读取已提交)：")]),_._v(" 一个事务提交之后，它做的变更才会被其他事务看到。可以阻止脏读，但是幻读或不可重复读仍有可能发生。")]),_._v(" "),v("li",[v("strong",[_._v("REPEATABLE-READ (可重复读)：")]),_._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),_._v(" "),v("li",[v("strong",[_._v("SERIALIZABLE(串行化)：")]),_._v(" 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("隔离级别")]),_._v(" "),v("th",[_._v("脏读")]),_._v(" "),v("th",[_._v("不可重复读")]),_._v(" "),v("th",[_._v("幻读")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("READ-UNCOMMITTED")]),_._v(" "),v("td",[_._v("可能发生")]),_._v(" "),v("td",[_._v("可能发生")]),_._v(" "),v("td",[_._v("可能发生")])]),_._v(" "),v("tr",[v("td",[_._v("READ-COMMITTED")]),_._v(" "),v("td",[_._v("不可能发生")]),_._v(" "),v("td",[_._v("可能发生")]),_._v(" "),v("td",[_._v("可能发生")])]),_._v(" "),v("tr",[v("td",[_._v("REPEATABLE-READ")]),_._v(" "),v("td",[_._v("不可能发生")]),_._v(" "),v("td",[_._v("不可能发生")]),_._v(" "),v("td",[_._v("可能发生")])]),_._v(" "),v("tr",[v("td",[_._v("SERIALIZABLE")]),_._v(" "),v("td",[_._v("不可能发生")]),_._v(" "),v("td",[_._v("不可能发生")]),_._v(" "),v("td",[_._v("不可能发生")])])])]),_._v(" "),v("p",[_._v("MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读），同时使用到了MVCC 和 Next-Key Locks 机制解决了幻读，详见 "),v("RouterLink",{attrs:{to:"/pages/Database/MySQL/06-MVCC.html"}},[_._v("06-MVCC")])],1),_._v(" "),v("h2",{attrs:{id:"事务隔离的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离的实现"}},[_._v("#")]),_._v(" 事务隔离的实现")]),_._v(" "),v("h2",{attrs:{id:"事务的启动方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的启动方式"}},[_._v("#")]),_._v(" 事务的启动方式")])])}),[],!1,null,null,null);v.default=r.exports}}]);